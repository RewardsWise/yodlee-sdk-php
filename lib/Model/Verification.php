<?php
/**
 * Verification
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Yodlee Core APIs
 *
 * This file describes the Yodlee Platform APIs using the swagger notation. You can use this swagger file to generate client side SDKs to the Yodlee Platform APIs for many different programming languages. Yodlee API v1.1 - Overview</a>.<br><br>You will have to set the header before making the API call. The following headers apply to all the APIs:<ul><li>Authorization: This header holds the access token</li> <li> Api-Version: 1.1</li></ul><b>Note</b>: If there are any API-specific headers, they are mentioned explicitly in the respective API's description.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: developer@yodlee.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * Verification Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class Verification implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Verification';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'account_id' => 'int',
        'reason' => 'string',
        'verification_status' => 'string',
        'provider_account_id' => 'int',
        'additional_message' => 'string',
        'verification_type' => 'string',
        'account' => '\OpenAPI\Client\Model\VerificationAccount',
        'verification_date' => 'string',
        'verification_id' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'account_id' => 'int64',
        'reason' => null,
        'verification_status' => null,
        'provider_account_id' => 'int64',
        'additional_message' => null,
        'verification_type' => null,
        'account' => null,
        'verification_date' => null,
        'verification_id' => 'int64'
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'account_id' => false,
        'reason' => false,
        'verification_status' => false,
        'provider_account_id' => false,
        'additional_message' => false,
        'verification_type' => false,
        'account' => false,
        'verification_date' => false,
        'verification_id' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'account_id' => 'accountId',
        'reason' => 'reason',
        'verification_status' => 'verificationStatus',
        'provider_account_id' => 'providerAccountId',
        'additional_message' => 'additionalMessage',
        'verification_type' => 'verificationType',
        'account' => 'account',
        'verification_date' => 'verificationDate',
        'verification_id' => 'verificationId'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'account_id' => 'setAccountId',
        'reason' => 'setReason',
        'verification_status' => 'setVerificationStatus',
        'provider_account_id' => 'setProviderAccountId',
        'additional_message' => 'setAdditionalMessage',
        'verification_type' => 'setVerificationType',
        'account' => 'setAccount',
        'verification_date' => 'setVerificationDate',
        'verification_id' => 'setVerificationId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'account_id' => 'getAccountId',
        'reason' => 'getReason',
        'verification_status' => 'getVerificationStatus',
        'provider_account_id' => 'getProviderAccountId',
        'additional_message' => 'getAdditionalMessage',
        'verification_type' => 'getVerificationType',
        'account' => 'getAccount',
        'verification_date' => 'getVerificationDate',
        'verification_id' => 'getVerificationId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const REASON_DATA_NOT_AVAILABLE = 'DATA_NOT_AVAILABLE';
    public const REASON_ACCOUNT_HOLDER_MISMATCH = 'ACCOUNT_HOLDER_MISMATCH';
    public const REASON_FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE = 'FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE';
    public const REASON_FULL_ACCOUNT_NUMBER_NOT_AVAILABLE = 'FULL_ACCOUNT_NUMBER_NOT_AVAILABLE';
    public const REASON_BANK_TRANSFER_CODE_NOT_AVAILABLE = 'BANK_TRANSFER_CODE_NOT_AVAILABLE';
    public const REASON_EXPIRED = 'EXPIRED';
    public const REASON_DATA_MISMATCH = 'DATA_MISMATCH';
    public const REASON_INSTRUCTION_GENERATION_ERROR = 'INSTRUCTION_GENERATION_ERROR';
    public const VERIFICATION_STATUS_INITIATED = 'INITIATED';
    public const VERIFICATION_STATUS_DEPOSITED = 'DEPOSITED';
    public const VERIFICATION_STATUS_SUCCESS = 'SUCCESS';
    public const VERIFICATION_STATUS_FAILED = 'FAILED';
    public const ADDITIONAL_MESSAGE_PENDING_PROCESSING = 'PENDING_PROCESSING';
    public const ADDITIONAL_MESSAGE_PROCESSED = 'PROCESSED';
    public const ADDITIONAL_MESSAGE_DEPOSITED = 'DEPOSITED';
    public const ADDITIONAL_MESSAGE_PENDING_VERIFICATION = 'PENDING_VERIFICATION';
    public const ADDITIONAL_MESSAGE_FAILED = 'FAILED';
    public const ADDITIONAL_MESSAGE_SUSPECTED_FRAUD = 'SUSPECTED_FRAUD';
    public const ADDITIONAL_MESSAGE_RESTRICTED_RTN = 'RESTRICTED_RTN';
    public const ADDITIONAL_MESSAGE_RESTRICTED_ACCOUNT = 'RESTRICTED_ACCOUNT';
    public const ADDITIONAL_MESSAGE_PENDING_PROCESSING_EXPIRED = 'PENDING_PROCESSING_EXPIRED';
    public const ADDITIONAL_MESSAGE_RETURNED = 'RETURNED';
    public const ADDITIONAL_MESSAGE_ACCOUNT_VERIFICATION_EXPIRED = 'ACCOUNT_VERIFICATION_EXPIRED';
    public const VERIFICATION_TYPE_MATCHING = 'MATCHING';
    public const VERIFICATION_TYPE_CHALLENGE_DEPOSIT = 'CHALLENGE_DEPOSIT';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getReasonAllowableValues()
    {
        return [
            self::REASON_DATA_NOT_AVAILABLE,
            self::REASON_ACCOUNT_HOLDER_MISMATCH,
            self::REASON_FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE,
            self::REASON_FULL_ACCOUNT_NUMBER_NOT_AVAILABLE,
            self::REASON_BANK_TRANSFER_CODE_NOT_AVAILABLE,
            self::REASON_EXPIRED,
            self::REASON_DATA_MISMATCH,
            self::REASON_INSTRUCTION_GENERATION_ERROR,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getVerificationStatusAllowableValues()
    {
        return [
            self::VERIFICATION_STATUS_INITIATED,
            self::VERIFICATION_STATUS_DEPOSITED,
            self::VERIFICATION_STATUS_SUCCESS,
            self::VERIFICATION_STATUS_FAILED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAdditionalMessageAllowableValues()
    {
        return [
            self::ADDITIONAL_MESSAGE_PENDING_PROCESSING,
            self::ADDITIONAL_MESSAGE_PROCESSED,
            self::ADDITIONAL_MESSAGE_DEPOSITED,
            self::ADDITIONAL_MESSAGE_PENDING_VERIFICATION,
            self::ADDITIONAL_MESSAGE_FAILED,
            self::ADDITIONAL_MESSAGE_SUSPECTED_FRAUD,
            self::ADDITIONAL_MESSAGE_RESTRICTED_RTN,
            self::ADDITIONAL_MESSAGE_RESTRICTED_ACCOUNT,
            self::ADDITIONAL_MESSAGE_PENDING_PROCESSING_EXPIRED,
            self::ADDITIONAL_MESSAGE_RETURNED,
            self::ADDITIONAL_MESSAGE_ACCOUNT_VERIFICATION_EXPIRED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getVerificationTypeAllowableValues()
    {
        return [
            self::VERIFICATION_TYPE_MATCHING,
            self::VERIFICATION_TYPE_CHALLENGE_DEPOSIT,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('account_id', $data ?? [], null);
        $this->setIfExists('reason', $data ?? [], null);
        $this->setIfExists('verification_status', $data ?? [], null);
        $this->setIfExists('provider_account_id', $data ?? [], null);
        $this->setIfExists('additional_message', $data ?? [], null);
        $this->setIfExists('verification_type', $data ?? [], null);
        $this->setIfExists('account', $data ?? [], null);
        $this->setIfExists('verification_date', $data ?? [], null);
        $this->setIfExists('verification_id', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getReasonAllowableValues();
        if (!is_null($this->container['reason']) && !in_array($this->container['reason'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'reason', must be one of '%s'",
                $this->container['reason'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getVerificationStatusAllowableValues();
        if (!is_null($this->container['verification_status']) && !in_array($this->container['verification_status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'verification_status', must be one of '%s'",
                $this->container['verification_status'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAdditionalMessageAllowableValues();
        if (!is_null($this->container['additional_message']) && !in_array($this->container['additional_message'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'additional_message', must be one of '%s'",
                $this->container['additional_message'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getVerificationTypeAllowableValues();
        if (!is_null($this->container['verification_type']) && !in_array($this->container['verification_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'verification_type', must be one of '%s'",
                $this->container['verification_type'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets account_id
     *
     * @return int|null
     */
    public function getAccountId()
    {
        return $this->container['account_id'];
    }

    /**
     * Sets account_id
     *
     * @param int|null $account_id Unique identifier for the account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     *
     * @return self
     */
    public function setAccountId($account_id)
    {
        if (is_null($account_id)) {
            throw new \InvalidArgumentException('non-nullable account_id cannot be null');
        }
        $this->container['account_id'] = $account_id;

        return $this;
    }

    /**
     * Gets reason
     *
     * @return string|null
     */
    public function getReason()
    {
        return $this->container['reason'];
    }

    /**
     * Sets reason
     *
     * @param string|null $reason The reason the account verification failed.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     *
     * @return self
     */
    public function setReason($reason)
    {
        if (is_null($reason)) {
            throw new \InvalidArgumentException('non-nullable reason cannot be null');
        }
        $allowedValues = $this->getReasonAllowableValues();
        if (!in_array($reason, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'reason', must be one of '%s'",
                    $reason,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['reason'] = $reason;

        return $this;
    }

    /**
     * Gets verification_status
     *
     * @return string|null
     */
    public function getVerificationStatus()
    {
        return $this->container['verification_status'];
    }

    /**
     * Sets verification_status
     *
     * @param string|null $verification_status The status of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
     *
     * @return self
     */
    public function setVerificationStatus($verification_status)
    {
        if (is_null($verification_status)) {
            throw new \InvalidArgumentException('non-nullable verification_status cannot be null');
        }
        $allowedValues = $this->getVerificationStatusAllowableValues();
        if (!in_array($verification_status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'verification_status', must be one of '%s'",
                    $verification_status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['verification_status'] = $verification_status;

        return $this;
    }

    /**
     * Gets provider_account_id
     *
     * @return int|null
     */
    public function getProviderAccountId()
    {
        return $this->container['provider_account_id'];
    }

    /**
     * Sets provider_account_id
     *
     * @param int|null $provider_account_id Unique identifier for the provider account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     *
     * @return self
     */
    public function setProviderAccountId($provider_account_id)
    {
        if (is_null($provider_account_id)) {
            throw new \InvalidArgumentException('non-nullable provider_account_id cannot be null');
        }
        $this->container['provider_account_id'] = $provider_account_id;

        return $this;
    }

    /**
     * Gets additional_message
     *
     * @return string|null
     */
    public function getAdditionalMessage()
    {
        return $this->container['additional_message'];
    }

    /**
     * Sets additional_message
     *
     * @param string|null $additional_message The additional information of the status of account verification.<br><br><b>Endpoints</b>:<ul><li>GET verification</li></ul><br><b>Applicable Values</b>
     *
     * @return self
     */
    public function setAdditionalMessage($additional_message)
    {
        if (is_null($additional_message)) {
            throw new \InvalidArgumentException('non-nullable additional_message cannot be null');
        }
        $allowedValues = $this->getAdditionalMessageAllowableValues();
        if (!in_array($additional_message, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'additional_message', must be one of '%s'",
                    $additional_message,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['additional_message'] = $additional_message;

        return $this;
    }

    /**
     * Gets verification_type
     *
     * @return string|null
     */
    public function getVerificationType()
    {
        return $this->container['verification_type'];
    }

    /**
     * Sets verification_type
     *
     * @param string|null $verification_type The account verification type.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
     *
     * @return self
     */
    public function setVerificationType($verification_type)
    {
        if (is_null($verification_type)) {
            throw new \InvalidArgumentException('non-nullable verification_type cannot be null');
        }
        $allowedValues = $this->getVerificationTypeAllowableValues();
        if (!in_array($verification_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'verification_type', must be one of '%s'",
                    $verification_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['verification_type'] = $verification_type;

        return $this;
    }

    /**
     * Gets account
     *
     * @return \OpenAPI\Client\Model\VerificationAccount|null
     */
    public function getAccount()
    {
        return $this->container['account'];
    }

    /**
     * Sets account
     *
     * @param \OpenAPI\Client\Model\VerificationAccount|null $account account
     *
     * @return self
     */
    public function setAccount($account)
    {
        if (is_null($account)) {
            throw new \InvalidArgumentException('non-nullable account cannot be null');
        }
        $this->container['account'] = $account;

        return $this;
    }

    /**
     * Gets verification_date
     *
     * @return string|null
     */
    public function getVerificationDate()
    {
        return $this->container['verification_date'];
    }

    /**
     * Sets verification_date
     *
     * @param string|null $verification_date The date of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     *
     * @return self
     */
    public function setVerificationDate($verification_date)
    {
        if (is_null($verification_date)) {
            throw new \InvalidArgumentException('non-nullable verification_date cannot be null');
        }
        $this->container['verification_date'] = $verification_date;

        return $this;
    }

    /**
     * Gets verification_id
     *
     * @return int|null
     */
    public function getVerificationId()
    {
        return $this->container['verification_id'];
    }

    /**
     * Sets verification_id
     *
     * @param int|null $verification_id Unique identifier for the verification request.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     *
     * @return self
     */
    public function setVerificationId($verification_id)
    {
        if (is_null($verification_id)) {
            throw new \InvalidArgumentException('non-nullable verification_id cannot be null');
        }
        $this->container['verification_id'] = $verification_id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


